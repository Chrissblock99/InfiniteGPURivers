#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0, r32f) readonly uniform image2D heightMap;
layout(binding = 1, r32f) readonly uniform image2D drainageAreaMap;

layout(binding = 2, r8i) writeonly uniform iimage2D steepestNeighbourOffsetIndexMap;
layout(binding = 3, r32f) writeonly uniform image2D receiverHeightMap;
layout(binding = 4, r32f) writeonly uniform image2D drainageAreaCopyMap;



uniform ivec2 srcPos;



const ivec2 mooreNeighbourhood[9] = ivec2[](
    ivec2( 0,  0),
    ivec2(-1,  1),
    ivec2( 0,  1),
    ivec2( 1,  1),
    ivec2(-1,  0),
    ivec2( 1,  0),
    ivec2(-1, -1),
    ivec2( 0, -1),
    ivec2( 1, -1)
);

const float inverseMooreNeighbourhoodDistances[9] = float[](
    0,
    1/sqrt(2),
    1,
    1/sqrt(2),
    1,
    1,
    1/sqrt(2),
    1,
    1/sqrt(2)
);

float fastSlope(ivec2 pos, float height, int offsetIndex) {
    return (imageLoad(heightMap, pos + mooreNeighbourhood[offsetIndex]).x - height) * inverseMooreNeighbourhoodDistances[offsetIndex];
}

int steepest(ivec2 pos) {
    float height = imageLoad(heightMap, pos).x;
    int index = 0;
    float minSlope = 0.0f;
    for (int i = 1; i < 9; i++) {
        float currentSlope = fastSlope(pos, height, i);
        if (currentSlope < minSlope) {
            minSlope = currentSlope;
            index = i;
        }
    }
    return index;
}

void main() {
    ivec2 pos = srcPos + ivec2(gl_GlobalInvocationID);

    int index = steepest(pos);
    imageStore(steepestNeighbourOffsetIndexMap, pos, ivec4(index));
    imageStore(receiverHeightMap, pos, imageLoad(heightMap, pos + mooreNeighbourhood[index])); //this imageLoad is doubled and could be optimized (steepest() already loads it)
    imageStore(drainageAreaCopyMap, pos, imageLoad(drainageAreaMap, pos));
}