#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;

// In
layout(binding = 0, r32f) readonly uniform image2D hf;
layout(binding = 1, r32f) readonly uniform image2D stream;

// Out
layout(binding = 2, r32f) writeonly uniform image2D out_hf;
layout(binding = 3, r32f) writeonly uniform image2D out_stream;

layout(binding = 4, r32f) readonly uniform image2D upliftBuffer;




// 0: Stream power
// 1: Stream power + Hillslope (Laplacian)
// 2: Stream power + Hillslope (Laplacian) + Debris slope
uniform int erosionMode = 0;

uniform float uplift = 0.01f;
uniform float k = 0.0005f;
uniform float k_d = 10.0f;
uniform float k_h = 2.0f;
uniform float p_sa = 0.8f;
uniform float p_sl = 2.0f;
uniform float dt = 50.0f;

const ivec2 next8[8] = ivec2[8](ivec2(0, 1), ivec2(1, 1), ivec2(1, 0), ivec2(1, -1),
ivec2(0, -1), ivec2(-1, -1), ivec2(-1, 0), ivec2(-1, 1));

float height(ivec2 p) { return imageLoad(hf, p).x; }

float stream(ivec2 p) { return imageLoad(stream, p).x; }

float uplift(ivec2 p) { return imageLoad(upliftBuffer, p).x; }

vec4 Read(ivec2 p) {
    vec4 ret;
    ret.x = height(p);      // Bedrock elevation
    ret.y = stream(p);      // Stream area
    ret.z = uplift(p);      // Uplift factor
    return ret;
}

void Write(ivec2 p, vec4 data) {
    imageStore(out_hf, p, data.x);
    imageStore(out_stream, p, data.y);
}

//slope (offset divided by distance) from p to q
float Slope(ivec2 p, ivec2 q) {
    float d = length(q - p);
    return (height(q) - height(p)) / d;
}


float Laplacian(ivec2 p) {
    float lapl = 0.0f;

    lapl += height(p + ivec2(1, 0)) - 2.0f * height(p) + height(p + ivec2(-1, 0));

    lapl += height(p + ivec2(0, 1)) - 2.0f * height(p) + height(p + ivec2(0, -1));

    return lapl;
}

//direction of lowest point (slope based) from p
ivec2 GetFlowSteepest(ivec2 p) {
    ivec2 d = ivec2(0, 0);
    float maxSlope = 0.0f;
    for (int i = 0; i < 8; i++) {
        float ss = Slope(p, p + next8[i]);
        if (ss < maxSlope) {
            maxSlope = ss;
            d = p + next8[i];
        }
    }
    return d;
}

//add together area of all neighbours where i am the most sloped down
float WaterSteepest(ivec2 p) {
    float water = 0.0f;
    for (int i = 0; i < 8; i++) {
        ivec2 q = p + next8[i];
        ivec2 fd = GetFlowSteepest(q);
        if (fd == p) {
            water += stream(q);
        }
    }
    return water;
}

void main() {
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);

    vec4 data = Read(p);


    // Flows accumulation at p
    data.y = 1.0 + WaterSteepest(p);

    // Erosion at p (relative to steepest)
    ivec2 d = GetFlowSteepest(p);
    float receiverHeight = height(d);
    float pslope = abs(Slope(d, p));

    float spe = k * pow(data.y, p_sa) * pow(pslope, p_sl);

    float newH = data.x;
    if (erosionMode == 0)       // Stream power
        newH -= dt * (spe);
    else if (erosionMode == 1)  // Stream power + Hillslope erosion (Laplacian)
        newH -= dt * (spe - k_h * Laplacian(p));
    else if (erosionMode == 2)  // Stream power + Hillslope erosion (Laplacian) + Debris flow
        newH -= dt * (spe - k_h * Laplacian(p) - k_d * pslope);
    newH = max(newH, receiverHeight);
    newH += dt * uplift * data.z;

    data.x = newH;
    Write(p, data);
}