#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;

// In
layout(binding = 0, r32f) readonly uniform image2D hf;
layout(binding = 1, r32f) readonly uniform image2D stream;

// Out
layout(binding = 2, r32f) writeonly uniform image2D out_hf;
layout(binding = 3, r32f) writeonly uniform image2D out_stream;

layout(binding = 4, r32f) readonly uniform image2D upliftBuffer;




// 0: Stream power
// 1: Stream power + Hillslope (Laplacian)
// 2: Stream power + Hillslope (Laplacian) + Debris slope
uniform int erosionMode = 0;

uniform float uplift = 0.01f;
uniform float k = 0.0005f;
uniform float k_d = 10.0f;
uniform float k_h = 2.0f;
uniform float p_sa = 0.8f;
uniform float p_sl = 2.0f;
uniform float dt = 50.0f;

const ivec2 next8[8] = ivec2[8](ivec2(0, 1), ivec2(1, 1), ivec2(1, 0), ivec2(1, -1),
ivec2(0, -1), ivec2(-1, -1), ivec2(-1, 0), ivec2(-1, 1));

const float inverseLength[8] = float[](1, 1/sqrt(2), 1, 1/sqrt(2), 1, 1/sqrt(2), 1, 1/sqrt(2));

float height(ivec2 pos) { return imageLoad(hf, pos).x; }

float stream(ivec2 pos) { return imageLoad(stream, pos).x; }

float uplift(ivec2 pos) { return imageLoad(upliftBuffer, pos).x; }

vec4 Read(ivec2 pos) {
    vec4 ret;
    ret.x = height(pos);      // Bedrock elevation
    ret.y = stream(pos);      // Stream area
    ret.z = uplift(pos);      // Uplift factor
    return ret;
}

void Write(ivec2 pos, vec4 data) {
    imageStore(out_hf, pos, data.x);
    imageStore(out_stream, pos, data.y);
}

//slope (offset divided by distance) from p to q
float Slope(ivec2 pos, ivec2 to) {
    float d = length(to - pos);
    return (height(to) - height(pos)) / d;
}

float fastSlope(ivec2 pos, int offsetIndex) {
    return (height(pos + next8[offsetIndex]) - height(pos)) * inverseLength[offsetIndex];
}


float Laplacian(ivec2 pos) {
    float lapl = 0.0f;

    lapl += height(pos + ivec2(1, 0)) - 2.0f * height(pos) + height(pos + ivec2(-1, 0));

    lapl += height(pos + ivec2(0, 1)) - 2.0f * height(pos) + height(pos + ivec2(0, -1));

    return lapl;
}

//direction of lowest point (slope based) from p
ivec2 GetFlowSteepest(ivec2 pos) {
    ivec2 d = pos;
    float maxSlope = 0.0f;
    for (int i = 0; i < 8; i++) {
        float ss = fastSlope(pos, i);
        if (ss < maxSlope) {
            maxSlope = ss;
            d = pos + next8[i];
        }
    }
    return d;
}

//add together area of all neighbours where i am the most sloped down
float WaterSteepest(ivec2 pos) {
    float water = 0.0f;
    for (int i = 0; i < 8; i++) {
        ivec2 q = pos + next8[i];
        ivec2 fd = GetFlowSteepest(q);
        if (fd == pos) {
            water += stream(q);
        }
    }
    return water;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    vec4 data = Read(pos);


    // Flows accumulation at p
    data.y = 1.0 + WaterSteepest(pos);

    // Erosion at p (relative to steepest)
    ivec2 d = GetFlowSteepest(pos);
    float receiverHeight = height(d);
    float pslope = abs(Slope(d, pos));

    float spe = k * pow(data.y, p_sa) * pow(pslope, p_sl);

    float newH = data.x;
    if (erosionMode == 0)       // Stream power
        newH -= dt * (spe);
    else if (erosionMode == 1)  // Stream power + Hillslope erosion (Laplacian)
        newH -= dt * (spe - k_h * Laplacian(pos));
    else if (erosionMode == 2)  // Stream power + Hillslope erosion (Laplacian) + Debris flow
        newH -= dt * (spe - k_h * Laplacian(pos) - k_d * pslope);
    newH = max(newH, receiverHeight);
    newH += dt * uplift * data.z;

    data.x = newH;
    Write(pos, data);
}