#version 450 core

// In
layout(binding = 0, r32f) writeonly uniform image2D bedrockMap;
layout(binding = 1, r32f) writeonly uniform image2D streamMap;

// Out
layout(binding = 2, r32f) readonly uniform image2D tempBedrockMap;
layout(binding = 3, r32f) readonly uniform image2D tempStreamMap;

layout(binding = 4, r32f) readonly uniform image2D upliftMap;

layout(binding = 5, r8i) readonly uniform iimage2D steepestMap;



uniform ivec2 srcPos;
uniform ivec2 size;

// 0: Stream power
// 1: Stream power + Hillslope (Laplacian)
// 2: Stream power + Hillslope (Laplacian) + Debris slope
uniform int erosionMode = 0;

uniform float uplift = 0.01f;
uniform float k = 0.0005f;
uniform float k_d = 10.0f;
uniform float k_h = 2.0f;
uniform float p_sa = 0.8f;
uniform float p_sl = 2.0f;
uniform float dt = 100.0f;

const ivec2 next9[9] = ivec2[9](ivec2(0, 1), ivec2(1, 1), ivec2(1, 0), ivec2(1, -1),
                                ivec2(0, -1), ivec2(-1, -1), ivec2(-1, 0), ivec2(-1, 1),
                                ivec2(0, 0));


float cellSize = 1176.47;

float slope(ivec2 p, ivec2 q) {
    if (p == q) return 0.0;
    float d = cellSize * length(vec2(p)-vec2(q));
    return (imageLoad(tempBedrockMap, q).x - imageLoad(tempBedrockMap, p).x) / d;
}


float laplacian_h(ivec2 p) {
    float lapl = 0.0;
    int i = p.x;
    int j = p.y;

    lapl += (imageLoad(tempBedrockMap, ivec2(i+1, j)).x - 2.0 * imageLoad(tempBedrockMap, ivec2(i, j)).x + imageLoad(tempBedrockMap, ivec2(i-1, j)).x);

    lapl += (imageLoad(tempBedrockMap, ivec2(i, j+1)).x - 2.0 * imageLoad(tempBedrockMap, ivec2(i, j)).x + imageLoad(tempBedrockMap, ivec2(i, j-1)).x);

    lapl /= cellSize*cellSize;

    return lapl;
}

float getDiffDrainageArea(ivec2 p) {
    float water = 0.0;
    for (int i = 0; i < 8; i++) {
        ivec2 q = p + next9[i];
        ivec2 fd = next9[imageLoad(steepestMap, q).x];
        if (q + fd == p) {
            water += imageLoad(tempStreamMap, q).x;
        }
    }
    return water;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main() {
    ivec2 offset = ivec2(gl_GlobalInvocationID.xy);
    ivec2 p = srcPos + offset;
    if (offset.x >= size.x || offset.y >= size.y) return;

    float h = imageLoad(tempBedrockMap, p).x;
    float da = sqrt(2.0) * cellSize + getDiffDrainageArea(p);
   
    // Erosion at p (relative to steepest)
    ivec2 downstream = p+next9[imageLoad(steepestMap, p).x];
    float pslope = abs(slope(downstream, p));

    float spe = k * pow(da, p_sa) * pow(pslope, p_sl);

    
    if (erosionMode == 0)       // Stream power
        h -= dt * (spe);
    else if (erosionMode == 1)  // Stream power + Hillslope erosion (Laplacian)
        h -= dt * (spe - k_h * laplacian_h(p));
    else if (erosionMode == 2)  // Stream power + Hillslope erosion (Laplacian) + Debris flow
        h -= dt * (spe - k_h * laplacian_h(p) - k_d * pslope);
    h = max(h, imageLoad(tempBedrockMap, downstream).x);
    h += dt * uplift * imageLoad(upliftMap, p).x;

    imageStore(bedrockMap, p, vec4(h));
    imageStore(streamMap, p, vec4(da));
}
