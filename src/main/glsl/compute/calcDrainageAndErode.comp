#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0, r32f) uniform image2D heightMap;
layout(binding = 1, r32f) uniform image2D drainageAreaMap;

layout(binding = 2, r8i) readonly uniform iimage2D steepestNeighbourOffsetIndexMap;
layout(binding = 3, r32f) readonly uniform image2D receiverHeightMap;
layout(binding = 4, r32f) readonly uniform image2D drainageAreaCopyMap;

layout(binding = 5, r32f) readonly uniform image2D upliftMap;



uniform ivec2 srcPos;



const float uplift = 0.01f;
const float k = 0.0005f;
const float k_d = 10.0f;
const float k_h = 2.0f;
const float p_sa = 0.8f;
const float p_sl = 2.0f;
const float dt = 50.0f;

const ivec2 mooreNeighbourhood[9] = ivec2[](
    ivec2( 0,  0),
    ivec2(-1,  1),
    ivec2( 0,  1),
    ivec2( 1,  1),
    ivec2(-1,  0),
    ivec2( 1,  0),
    ivec2(-1, -1),
    ivec2( 0, -1),
    ivec2( 1, -1)
);

const float inverseMooreNeighbourhoodDistances[9] = float[](
    0,
    1/sqrt(2),
    1,
    1/sqrt(2),
    1,
    1,
    1/sqrt(2),
    1,
    1/sqrt(2)
);

float fastSlopeBothHeights(float height, float otherHeight, int offsetIndex) {
    return (otherHeight - height) * inverseMooreNeighbourhoodDistances[offsetIndex];
}

float accumulateDrainageArea(ivec2 pos) {
    float drainageArea = 0.0;
    for (int i = 1; i < 9; i++) {
        ivec2 offsetPos = pos + mooreNeighbourhood[i];
        if (imageLoad(steepestNeighbourOffsetIndexMap, offsetPos).x + i == 9) //checks if the offset indexes are "inverses"
            drainageArea += imageLoad(drainageAreaMap, offsetPos).x;
    }
    return drainageArea;
}

void main() {
    ivec2 pos = srcPos + ivec2(gl_GlobalInvocationID.xy);

    float drainageArea = 1.0 + accumulateDrainageArea(pos);

    // Erosion at p (relative to steepest)
    float height = imageLoad(heightMap, pos).x;
    int offsetIndex = imageLoad(steepestNeighbourOffsetIndexMap, pos).x;
    float receiverHeight = imageLoad(receiverHeightMap, pos).x;
    float positiveSlope = abs(fastSlopeBothHeights(height, receiverHeight, offsetIndex));

    float spe = k * pow(drainageArea, p_sa) * pow(positiveSlope, p_sl);

    height -= dt * (spe);
    height = max(height, receiverHeight);
    height += dt * uplift * imageLoad(upliftMap, pos).x;

    imageStore(drainageAreaMap, pos, vec4(drainageArea));
    imageStore(heightMap, pos, vec4(height));
}