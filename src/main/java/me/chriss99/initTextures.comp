#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;
layout(binding = 0, r32f) restrict writeonly uniform image2D terrainMap;
layout(binding = 1, r32f) restrict writeonly uniform image2D waterMap;
layout(binding = 2, r32f) restrict writeonly uniform image2D sedimentMap;
layout(binding = 3, r32f) restrict writeonly uniform image2D hardnessMap;
layout(binding = 4, rgba32f) restrict writeonly uniform image2D waterOutflowPipes;

// start - credit to Stefan Gustavson AKA stegu
// https://github.com/stegu/perlin-noise/blob/master/src/sdnoise1234.c
const int[] permA = {151,160,137,91,90,15,
131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
};

const vec2[] grad2lut = {
vec2(-1.0f, -1.0f), vec2(1.0f, 0.0f), vec2(-1.0f, 0.0f), vec2(1.0f, 1.0f),
vec2(-1.0f, 1.0f), vec2(0.0f, -1.0f), vec2(0.0f, 1.0f), vec2(1.0f, -1.0f)
};

vec2 grad2(int hash) {
    int h = hash & 7;
    return grad2lut[h];
}

int permutate(int i, int seed) {
    //& 0xff is equivalent to mod(a, 156)
    return permA[(i + seed * 5 + 134) & 0xff];
}

const float F2 = 0.366025403;
const float G2 = 0.211324865;

vec3 simplexNoiseDeriv(vec2 p, int seed, bool deriv) {
    float n0, n1, n2; /* Noise contributions from the three simplex corners */
    vec2 g0, g1, g2; /* Gradients at simplex corners */
    float t0, t1, t2, x1, x2, y1, y2;
    float t20, t40, t21, t41, t22, t42;
    float temp0, temp1, temp2, noise;
    vec2 dnoise_d;

    /* Skew the input space to determine which simplex cell we're in */
    float s = (p.x + p.y) * F2; /* Hairy factor for 2D */
    float xs = p.x + s;
    float ys = p.y + s;
    int ii, i = int(floor(xs));
    int jj, j = int(floor(ys));

    float t = float(i + j) * G2;
    float X0 = float(i) - t; /* Unskew the cell origin back to (x,y) space */
    float Y0 = float(j) - t;
    float x0 = float(p.x) - X0; /* The x,y distances from the cell origin */
    float y0 = float(p.y) - Y0;

    /* For the 2D case, the simplex shape is an equilateral triangle.
     * Determine which simplex we are in. */
    int i1, j1; /* Offsets for second (middle) corner of simplex in (i,j) coords */
    if (x0 > y0 ) { /* lower triangle, XY order: (0,0)->(1,0)->(1,1) */
        i1 = 1;
        j1 = 0;
    } else { /* upper triangle, YX order: (0,0)->(0,1)->(1,1) */
        i1 = 0;
        j1 = 1;
    }

    /* A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
     * a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
     * c = (3-sqrt(3))/6   */
    x1 = x0 - float(i1) + G2; /* Offsets for middle corner in (x,y) unskewed coords */
    y1 = y0 - float(j1) + G2;
    x2 = x0 - 1.0f + 2.0f * G2; /* Offsets for last corner in (x,y) unskewed coords */
    y2 = y0 - 1.0f + 2.0f * G2;

    /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */
    ii = i & 0xff;
    jj = j & 0xff;

    /* Calculate the contribution from the three corners */
    t0 = 0.5f - x0 * x0 - y0 * y0;
    if (t0 < 0.0f)
    t40 = t20 = t0 = n0 = g0.x = g0.y = 0.0f; /* No influence */
    else {
        g0 = grad2(permutate(ii + permutate(jj, seed), seed));
        t20 = t0 * t0;
        t40 = t20 * t20;
        n0 = t40 * (g0.x * x0 + g0.y * y0);
    }

    t1 = 0.5f - x1 * x1 - y1 * y1;
    if (t1 < 0.0f)
    t21 = t41 = t1 = n1 = g1.x = g1.y = 0.0f; /* No influence */
    else {
        g1 = grad2(permutate(ii + i1 + permutate(jj + j1, seed), seed));
        t21 = t1 * t1;
        t41 = t21 * t21;
        n1 = t41 * (g1.x * x1 + g1.y * y1);
    }

    t2 = 0.5f - x2 * x2 - y2 * y2;
    if (t2 < 0.0f)
    t42 = t22 = t2 = n2 = g2.x = g2.y = 0.0f; /* No influence */
    else {
        g2 = grad2(permutate(ii + 1 + permutate(jj + 1, seed), seed));
        t22 = t2 * t2;
        t42 = t22 * t22;
        n2 = t42 * (g2.x * x2 + g2.y * y2);
    }

    /* Add contributions from each corner to get the final noise value.
     * The result is scaled to return values in the interval [-1,1]. */
    noise = 40.0f * (n0 + n1 + n2);

    if (deriv) {
        /*  A straight, unoptimised calculation would be like:
         *    *dnoise_dx = -8.0f * t20 * t0 * x0 * ( gx0 * x0 + gy0 * y0 ) + t40 * gx0;
         *    *dnoise_dy = -8.0f * t20 * t0 * y0 * ( gx0 * x0 + gy0 * y0 ) + t40 * gy0;
         *    *dnoise_dx += -8.0f * t21 * t1 * x1 * ( gx1 * x1 + gy1 * y1 ) + t41 * gx1;
         *    *dnoise_dy += -8.0f * t21 * t1 * y1 * ( gx1 * x1 + gy1 * y1 ) + t41 * gy1;
         *    *dnoise_dx += -8.0f * t22 * t2 * x2 * ( gx2 * x2 + gy2 * y2 ) + t42 * gx2;
         *    *dnoise_dy += -8.0f * t22 * t2 * y2 * ( gx2 * x2 + gy2 * y2 ) + t42 * gy2;
         */
        temp0 = t20 * t0 * (g0.x * x0 + g0.y * y0);
        dnoise_d = temp0 * vec2(x0, y0);
        temp1 = t21 * t1 * ( g1.x * x1 + g1.y * y1 );
        dnoise_d += temp1 * vec2(x1, y1);
        temp2 = t22 * t2 * ( g2.x * x2 + g2.y * y2 );
        dnoise_d += temp2 * vec2(x2, y2);
        dnoise_d *= -8.0f;
        dnoise_d += t40 * g0 + t41 * g1 + t42 * g2;
        dnoise_d *= 40.0f; /* Scale derivative to match the noise scaling */
    }

    return vec3(dnoise_d, noise);
}
// end - credit to Stefan Gustavson AKA stegu

const int octaves = 8;
const float freq = 0.0015;
const float amp = 60;
const float lacunarity = 2;
const float persistence = .5;

void main() {
    float height = 0;

    float localFreq = freq;
    float localAmp = amp;

    for (int i = 0; i < octaves; i++) {
        height += simplexNoiseDeriv(vec2(gl_GlobalInvocationID) * localFreq, i, false).z * localAmp;
        localFreq *= lacunarity;
        localAmp *= persistence;
    }

    imageStore(terrainMap, ivec2(gl_GlobalInvocationID.xy), vec4(height));
    imageStore(waterMap, ivec2(gl_GlobalInvocationID.xy), vec4(0));
    imageStore(sedimentMap, ivec2(gl_GlobalInvocationID.xy), vec4(0));
    imageStore(hardnessMap, ivec2(gl_GlobalInvocationID.xy), vec4(1));
    imageStore(waterOutflowPipes, ivec2(gl_GlobalInvocationID.xy), vec4(0));
}