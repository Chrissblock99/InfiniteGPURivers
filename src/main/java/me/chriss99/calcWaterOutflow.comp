#version 450 core
layout(local_size_x = 1, local_size_y = 1) in;
layout(binding = 0, r16f) restrict readonly uniform image2D terrainMap;
layout(binding = 1, r16f) restrict readonly uniform image2D waterMap;
layout(binding = 4, rgba16f) restrict uniform image2D waterOutflowPipes;

const float deltaT = 0.02; //[0;0.05]
const float waterFlowMultiplier = 1; //[0.1;2]

const ivec2 vonNeumannNeighbourhood[4] = ivec2[](
    ivec2( 0,  1),
    ivec2(-1,  0),
    ivec2( 1,  0),
    ivec2( 0, -1)
);

void main() {
    float waterHeight = imageLoad(waterMap, ivec2(gl_GlobalInvocationID)).x;
    float waterHeights[4];
    for (int i = 0; i < 4; i++)
        waterHeights[i] = imageLoad(waterMap, ivec2(gl_GlobalInvocationID) + vonNeumannNeighbourhood[i]).x;

    vec4 outflowVec = imageLoad(waterOutflowPipes, ivec2(gl_GlobalInvocationID));
    float waterOutflowPipesArray[4] = float[](outflowVec.x, outflowVec.y, outflowVec.z, outflowVec.w);



    float totalOutFlow = 0;

    //TODO this can probably be optimized by using componentwise max, keeping the outflow as a vector and packing the adjacent water heights into a vector aswell
    for (int i = 0; i < 4; i++) {
        float outFlow = max(0, waterOutflowPipesArray[i] +
                deltaT * (waterHeight - waterHeights[i]) * waterFlowMultiplier);
        waterOutflowPipesArray[i] = outFlow;
        //and adding this together is possible with a scalar product of the vector and a vec(1)          (probably a bad idea)
        totalOutFlow += outFlow;
    }

    outflowVec = vec4(waterOutflowPipesArray[0], waterOutflowPipesArray[1], waterOutflowPipesArray[2], waterOutflowPipesArray[3]);

    if (totalOutFlow > waterHeight) {
        float flowScalar = waterHeight / totalOutFlow;
        outflowVec *= flowScalar;
    }

    imageStore(waterOutflowPipes, ivec2(gl_GlobalInvocationID), outflowVec);
}